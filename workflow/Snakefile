'''
Joint variant calling with GATK HaplotypeCaller, Google DeepVariant and Illumina Strelka2. 

Notes:
    This pipeline is for use with the production germline pipeline.
    Therefore, some things are assumed, e.g. that input bams are indexed,
    that the reference genome is appropriately indexed, etc.  The pipeline
    will halt if these assumptions are not true, but there are no rules
    to perform these tasks.

Input:
    Customized config.yaml, sorted/indexed bams

Output:
    Merged multi-sample VCFs, one called with HaplotypeCaller, one
    called with DeepVariant, and one called with Strelka2

'''


import os
import subprocess
import glob
from pathlib import Path
from datetime import datetime
from snakemake.remote.GS import RemoteProvider as GSRemoteProvider

# reference the config file
configfile: "../config/config.yaml"
report: 'report/workflow.rst'

# import variables from the config file
hc_mode = config['runMode']['haplotypeCaller']
dv_mode = config['runMode']['deepVariant']
strelka2_mode = config['runMode']['streka2']
har_mode = config['runMode']['harmonize']
refGenome = config['refGenome']
#snakePath = config['snakePath'].rstrip('/') + '/'
bedFile = config['bedFile']
by_chrom = config['by_chrom']
threads = config['threads']
clusterMode = config['clusterMode']
outputDir = config['outputDir']

if clusterMode == "gcp":
    GS = GSRemoteProvider()


def get_sm_tag(bam): 
    if Path(bam).is_file():
        command = 'samtools view -H ' + bam + ' | grep "^@RG" | grep -Eo "SM[^[:space:]]+" | cut -d":" -f2 | uniq'
        sm = subprocess.check_output(command, shell=True).decode('ascii').rstrip()
        return sm

def get_bam(wildcards):
    bam = wildcards.sample + ".bam"
    return(bam)  

def get_bam_index(wildcards):
    bam = sample2bam[wildcards.sample]
    return(bam + '.bai')    

def path_sanitize(path):
    if clusterMode == "gcp":
        return GS.remote(path)
    else:
        return path

if dv_mode:
    #modelPath = config['modelPath']
    #useShards = config['useShards']
    model_type = config['model_type']

if strelka2_mode:
    bedFileGZ = config['bedFileGZ']
    glnexusConfig = config['glnexusConfig']
    exome_param = config['exome_param']
    memGB = config['memGB']


CALLERS = ['HC', 'DV', 'strelka2']  # used in harmonize module

# derive additional refgenome variables
refFile = os.path.basename(refGenome)
refDir = os.path.dirname(refGenome)
refNoExt = os.path.splitext(refFile)[0]
dictionaryFile = refDir + '/' + refNoExt + '.dict'

# set a datetime stamp for GATK DBImport step
dt = str(datetime.now().strftime("%y-%m-%d-%H-%M"))
#dt = str(config['dt'])

#fix this later
bamList = config['inputBamsList']

# read samples file
#samplesFile = config['samplesFile']
#with open('samplesFile') as f:
#    bamList = [line.rstrip() for line in f]

# generate sampleList based on bam filenames and then we generate the sample to bam dict
sampleList = [os.path.splitext(os.path.basename(f))[0] for f in bamList]
sample2bam = dict(zip(sampleList, bamList))

# generate sample names list from bam SM tags and then generate the sample to sm tag dic
# get_all_sm_tag = lambda x: get_sm_tag(x)
# smList = list(map(get_all_sm_tag, bamList))


sample2sm =  dict(zip(sampleList, sampleList))

# read in chromosome list from reference dict file (assumes the dict is already created)
# this circumvents the issue of whether to use hg19-style or b37-style chromosome annotation
# as it just pulls the chromosome names directly from the dict index.
chromList = config['chromsList'] 


def get_DBImport_path1(wildcards):
    return(glob.glob('HaplotypeCaller/DBImport/' +  wildcards.chrom + '/' + wildcards.chrom + '*/genomicsdb_meta_dir/genomicsdb_meta*.json'))

def get_DBImport_path2(wildcards):
    path = ''.join(glob.glob('HaplotypeCaller/DBImport/' + wildcards.chrom + '/*/__*/'))
    myList = []
    if os.path.exists(path):
        myList = ['AD.tdb', 'AD_var.tdb', 'ALT.tdb', 'ALT_var.tdb', 'BaseQRankSum.tdb', '__book_keeping.tdb.gz', '__coords.tdb', 'DP_FORMAT.tdb', 'DP.tdb', 'DS.tdb', 'END.tdb', 'ExcessHet.tdb', 'FILTER.tdb', 'FILTER_var.tdb', 'GQ.tdb', 'GT.tdb', 'GT_var.tdb', 'ID.tdb', 'ID_var.tdb', 'InbreedingCoeff.tdb', 'MIN_DP.tdb', 'MLEAC.tdb', 'MLEAC_var.tdb', 'MLEAF.tdb', 'MLEAF_var.tdb', 'MQRankSum.tdb', 'PGT.tdb', 'PGT_var.tdb', 'PID.tdb', 'PID_var.tdb', 'PL.tdb', 'PL_var.tdb', 'QUAL.tdb', 'RAW_MQandDP.tdb', 'ReadPosRankSum.tdb', 'REF.tdb', 'REF_var.tdb', 'SB.tdb', '__tiledb_fragment.tdb']
        myList = [path + file for file in myList]
    return(myList)

def get_DV_model_path(model_type):
    if clusterMode == "gcp":
        model_path = os.system("ls -d $CONDA_PREFIX/share/deepvariant*/models/DeepVariant/*/DeepVariant*" + 
                   model_type + "_standard")
    else:
        model_path =  modelPath + "/DeepVariant-inception_v3-1.0.0+data-" + model_type + "_standard/"
    return model_path    

if strelka2_mode and not dv_mode and not hc_mode:
    include: 'rules/Snakefile_Strelka2'
    rule all:
        input:
            'strelka2/genotyped/strelka2_variants.vcf.gz'

if hc_mode and not dv_mode and not strelka2_mode:
    include: 'rules/Snakefile_HaplotypeCaller'
    rule all:
        input:
            'HaplotypeCaller/genotyped/combined/HC_variants.vcf.gz'

if dv_mode and not hc_mode and not strelka2_mode:
    include: 'rules/Snakefile_DeepVariant'
    rule all:
        input:
            expand('deepVariant/called/vcfs/{sample}_all_chroms.vcf.gz', sample=sampleList) if by_chrom else expand('deepVariant/called_by_sample/{sample}.vcf.gz', sample=sampleList),
            'deepVariant/genotyped/DV_variants.vcf.gz'
            #'deepVariant/called/chr22/HG002.SequelII.merged_15kb_20kb.pbmm2.GRCh38.haplotag.10x.vcf.gz'
if hc_mode and dv_mode and not har_mode:
    include: 'rules/Snakefile_HaplotypeCaller'
    include: 'rules/Snakefile_DeepVariant'
    rule all:
        input:
            'HaplotypeCaller/genotyped/combined/HC_variants.vcf.gz',
            expand('deepVariant/called/vcfs/{sample}_all_chroms.vcf.gz', sample=sampleList) if by_chrom else expand('deepVariant/called_by_sample/{sample}.vcf.gz', sample=sampleList),
            'deepVariant/genotyped/DV_variants.vcf.gz'
if hc_mode and dv_mode and strelka2_mode and not har_mode:
    include: 'rules/Snakefile_HaplotypeCaller'
    include: 'rules/Snakefile_DeepVariant'
    include: 'ruless/Snakefile_Strelka2'
    rule all:
        input:
            'HaplotypeCaller/genotyped/combined/HC_variants.vcf.gz',
            expand('deepVariant/called/vcfs/{sample}_all_chroms.vcf.gz', sample=sampleList) if by_chrom else expand('deepVariant/called_by_sample/{sample}.vcf.gz', sample=sampleList),
            'deepVariant/genotyped/DV_variants.vcf.gz',   
            'strelka2/genotyped/strelka2_variants.vcf.gz'
if hc_mode and dv_mode and strelka2_mode and har_mode:
    include: 'rules/Snakefile_HaplotypeCaller'
    include: 'rules/Snakefile_DeepVariant'
    include: 'rules/Snakefile_Strelka2'
    include: 'rules/Snakefile_harmonize'
    rule all:
        input:
            expand('deepVariant/called/vcfs/{sample}_all_chroms.vcf.gz', sample=list(sample2bam.keys()) ) if by_chrom else expand('deepVariant/called_by_sample/{sample}.vcf.gz', sample=sampleList),
            'ensemble/all_callers_merged_genotypes.vcf.gz',
            'ensemble/all_callers_merged_genotypes.vcf.gz.tbi'

rule split_bed_file:
    '''
    Separates bed regions by chromosome.

    For DV:
    If you're not assigning a number of shards by which to divide
    and parallelize, then the pipeline will parallelize by chrom.
    To do this, we take the bed file (e.g. exome capture region)
    and split the regions by chromosome.  Subsequent steps are run
    concurrently on each of the single-chromosome bed files.

    For GATK:
    HaplotypeCaller can't be parallelized per task (e.g. threads),
    so must be run over sub-regions if you want parallelization.
    **Do we want to use the old 4000-region bed file, or is by-chrom
    sufficient?

    Note that grep exits with 0 if a match is found, 1 if no match,
    and 2 if error.  Snakemake looks for exit codes of 0 to determine
    that a job finished successfully.  No match is an acceptable outcome
    here, so the shell command below should allow match or no match.

    don't love the || true solution; what will it do for exit > 1?
    '''
    input:
        bed = GS.remote(bedFile) if clusterMode == "gcp" else bedFile
    output:
        bed =  'split_regions/{chrom}.bed'
    benchmark:
        'run_times/split_bed_file/{chrom}.tsv'
    conda:
        "envs/environment.yaml"  
    log:
        "logs/split_bed_file/split_bed_file.{chrom}.log"     
    shell:
        'grep "^{wildcards.chrom}[[:space:]]" {input.bed} > {output.bed} || true'
